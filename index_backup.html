<!DOCTYPE html>
<html>
<head>
    <title>Floating Bubbles</title>
    <style>
        canvas {
            background: #1a1a1a;
            display: block;
            margin: 0 auto;
        }
        body {
            margin: 0;
            overflow: hidden;
        }
        #textInput {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #444;
            background: rgba(26, 26, 26, 0.8);
            color: white;
            font-size: 16px;
            resize: none;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
        }

        #textInput::placeholder {
            color: #888;
        }

        #textInput:focus {
            outline: none;
            border-color: #666;
        }
    </style>
</head>
<body>
    <canvas id="bubbleCanvas"></canvas>
    <textarea id="textInput"
              placeholder="Type or paste text here to update the bubbles..."
              rows="3"></textarea>
    <script>
        let wordCounts = {};

        window.onload = function() {
            // Add event listener for the text input
            document.getElementById('textInput').addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // Prevent default newline
                    updateWordCounts(this.value); // Update bubbles with current text
                    this.value = ''; // Clear the input
                }
            });

            // Initialize canvas and start loading poem
            initCanvas();
            loadPoemLines();
        };

        const canvas = document.getElementById('bubbleCanvas');
        const ctx = canvas.getContext('2d');

        // Bubble class
        class Bubble {
            constructor(word, count) {
                // Base size on word frequency (count)
                const minSize = 70;
                const maxSize = 120;
                const sizeMultiplier = 17;
                this.targetRadius = count * sizeMultiplier;
                this.baseRadius = this.targetRadius;
                this.radius = this.targetRadius;
                this.growthSpeed = 0.1; // Speed of size change animation

                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.speedX = (Math.random() - 0.5) * 2;
                this.speedY = (Math.random() - 0.5) * 2;
                this.opacity = Math.random() * 0.5 + 0.3;

                this.r = Math.floor(Math.random() * 256);
                this.g = Math.floor(Math.random() * 256);
                this.b = Math.floor(Math.random() * 256);

                this.text = word; // +`[${count}]`; // Use the word from wordCounts
                this.count = count;
            }

            draw() {
                // Draw bubble
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.r}, ${this.g}, ${this.b}, ${this.opacity})`;
                ctx.fill();

                // Draw shine
                ctx.beginPath();
                ctx.arc(this.x - this.radius/3, this.y - this.radius/3,
                       this.radius/4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.r + 40}, ${this.g + 40}, ${this.b + 40}, ${this.opacity + 0.2})`;
                ctx.fill();

                // Draw text with lighter version of bubble color
                ctx.fillStyle = `rgba(${Math.min(255, this.r + 100)},
                                    ${Math.min(255, this.g + 100)},
                                    ${Math.min(255, this.b + 100)},
                                    ${Math.min(1, this.opacity + 0.4)})`;
                ctx.font = `${this.radius/3}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, this.x, this.y);
            }

            update() {
                // Animate towards target size
                if (this.radius !== this.targetRadius) {
                    const diff = this.targetRadius - this.radius;
                    this.radius += diff * this.growthSpeed;
                    this.baseRadius = this.radius; // Update base radius for pulse effect
                }

                // Move bubble
                this.x += this.speedX;
                this.y += this.speedY;

                // Bounce off walls - ensure bubble stays completely within canvas
                if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.speedX = -this.speedX;
                } else if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.speedX = -this.speedX;
                }

                if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.speedY = -this.speedY;
                } else if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.speedY = -this.speedY;
                }

                // Check collision with other bubbles
                bubbles.forEach(otherBubble => {
                    if (otherBubble === this) return;

                    const dx = otherBubble.x - this.x;
                    const dy = otherBubble.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.radius + otherBubble.radius) {
                        // Collision detected - calculate new velocities
                        const angle = Math.atan2(dy, dx);
                        const sin = Math.sin(angle);
                        const cos = Math.cos(angle);

                        // Rotate velocities
                        const vx1 = this.speedX * cos + this.speedY * sin;
                        const vy1 = this.speedY * cos - this.speedX * sin;
                        const vx2 = otherBubble.speedX * cos + otherBubble.speedY * sin;
                        const vy2 = otherBubble.speedY * cos - otherBubble.speedX * sin;

                        // Swap the velocities
                        this.speedX = vx2 * cos - vy1 * sin;
                        this.speedY = vy1 * cos + vx2 * sin;
                        otherBubble.speedX = vx1 * cos - vy2 * sin;
                        otherBubble.speedY = vy2 * cos + vx1 * sin;

                        // Move bubbles apart to prevent sticking
                        const overlap = (this.radius + otherBubble.radius - distance) / 2;
                        this.x -= overlap * cos;
                        this.y -= overlap * sin;
                        otherBubble.x += overlap * cos;
                        otherBubble.y += overlap * sin;
                    }
                });
            }
        }

        // Create array of bubbles
        const bubbles = [];

        // Move canvas initialization to a separate function
        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function initBubbles() {
            let skipWords = ['the', 'and', 'to', 'of', 'in', 'is', 'that', 'it', 'was', 'for', 'with', 'a', 'as', 'at', 'by', 'an', 'be', 'this', 'which', 'or', 'from', 'but', 'not', 'are'];

            // Update to handle Map iteration correctly
            for (let [word, count] of wordCounts) {
                if (count > 1 && !skipWords.includes(word)) {
                    bubbles.push(new Bubble(word, count));
                }
            }
            animate();
        }

        // Animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            bubbles.forEach(bubble => {
                bubble.update();
                bubble.draw();
            });

            requestAnimationFrame(animate);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Fetch and read the file before creating bubbles
        async function loadPoemLines() {
            try {
                const response = await fetch('Still_I_Rise.txt');
                const text = await response.text();
                const poemLines = text.split(/\s+/)
                    .map(word => word.replace(/[^\w\s]|_/g, "").trim())
                    .filter(line => line !== '');
                wordCounts = getWordFrequency(poemLines); // Store in global wordCounts
                initBubbles(); // Only create bubbles after we have the word counts
            } catch (error) {
                console.error('Error loading the poem:', error);
            }
        }

        function getWordFrequency(words) {
            // Create a Map to store word counts
            const wordCounts = new Map();

            // Count occurrences of each word
            words.forEach(word => {
                const lowercaseWord = word.toLowerCase(); // normalize words to lowercase
                wordCounts.set(lowercaseWord, (wordCounts.get(lowercaseWord) || 0) + 1);
            });

            // Convert to array and sort by count (descending)
            const sortedWords = Array.from(wordCounts.entries())
                .sort((a, b) => b[1] - a[1]);

            // Convert back to Map to maintain order
            return new Map(sortedWords);
        }

        // Add this new function to handle text updates
        function updateWordCounts(newText) {
            const words = newText.split(/\s+/)
                .map(word => word.replace(/[^\w\s]|_/g, "").trim())
                .filter(line => line !== '');

            const newWordCounts = getWordFrequency(words);
            const skipWords = ['the', 'and', 'to', 'of', 'in', 'is', 'that', 'it', 'was', 'for', 'with', 'a', 'as', 'at', 'by', 'an', 'be', 'this', 'which', 'or', 'from', 'but', 'not', 'are'];

            // Merge new word counts with existing ones
            newWordCounts.forEach((count, word) => {
                const existingCount = wordCounts.get(word) || 0;
                wordCounts.set(word, existingCount + count);
            });

            // Update existing bubbles
            bubbles.forEach(bubble => {
                const newCount = wordCounts.get(bubble.text.toLowerCase()) || 0;
                if (newCount > 1 && !skipWords.includes(bubble.text.toLowerCase())) {
                    bubble.targetRadius = newCount * 17; // Use same sizeMultiplier as constructor
                }
            });

            // Add new bubbles for new words
            wordCounts.forEach((count, word) => {
                if (count > 1 && !skipWords.includes(word)) {
                    // Check if bubble already exists
                    const existingBubble = bubbles.find(b => b.text.toLowerCase() === word.toLowerCase());
                    if (!existingBubble) {
                        bubbles.push(new Bubble(word, count));
                    }
                }
            });
        }
    </script>
</body>
</html>
